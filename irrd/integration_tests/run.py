# flake8: noqa: W293
import sys
import time

import os
import signal
import socket
import sqlalchemy as sa
import subprocess
import textwrap
import yaml
from alembic import command, config
from typing import List

from irrd.conf import config_init, PASSWORD_HASH_DUMMY_VALUE
from irrd.utils.rpsl_samples import (SAMPLE_MNTNER, SAMPLE_PERSON, SAMPLE_KEY_CERT, SIGNED_PERSON_UPDATE_VALID,
                                     SIGNED_PERSON_UPDATE_INVALID)
from irrd.utils.whois_client import whois_query
from .data import EMAIL_SMTP_PORT, EMAIL_DISCARD_MSGS_COMMAND, EMAIL_RETURN_MSGS_COMMAND, EMAIL_SEPARATOR, EMAIL_END

IRRD_ROOT_PATH = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(os.path.realpath(__file__)))))
sys.path.append(IRRD_ROOT_PATH)


class TestIntegration:
    """
    Note that this test will not be included in the default py.test discovery,
    this is intentional.
    """
    port_http1 = 6080
    port_whois1 = 6043
    port_http2 = 6081
    port_whois2 = 6044

    def test_irrd_integration(self, tmpdir):
        # IRRD_DATABASE_URL overrides the yaml config, so should be removed
        del os.environ['IRRD_DATABASE_URL']
        # PYTHONPATH needs to contain the twisted plugin path.
        os.environ['PYTHONPATH'] = IRRD_ROOT_PATH
        os.environ['IRRD_SCHEDULER_TIMER_OVERRIDE'] = '1'
        self.tmpdir = tmpdir

        self._start_mailserver()
        self._start_irrds()

        self._submit_update(self.config_path1,
                            SAMPLE_MNTNER + '\n\n' + SAMPLE_PERSON + '\n\npassword: md5-password')
        mails = self._retrieve_mails()
        assert len(mails) == 1
        assert b'\nSubject: SUCCESS: my subject\n' in mails[0]
        assert b'\nFrom: from@example.com\n' in mails[0]
        assert b'\nTo: Sasha <sasha@example.com>\n' in mails[0]
        assert b'Create succeeded: [mntner] TEST-MNT' in mails[0]
        assert b'Create succeeded: [person] PERSON-TEST' in mails[0]
        assert b'email footer' in mails[0]
        assert b'Generated by IRRd version ' in mails[0]

        # Load a regular mntner and person into the DB, and verify
        # the contents of the result.
        mntner_text = whois_query('127.0.0.1', self.port_whois1, 'TEST-MNT')
        assert 'TEST-MNT' in mntner_text
        assert PASSWORD_HASH_DUMMY_VALUE in mntner_text
        assert 'PERSON-TEST' in mntner_text

        # Check whether the objects can be queried from irrd #1
        mntner_text = whois_query('127.0.0.1', self.port_whois1, 'TEST-MNT')
        assert 'TEST-MNT' in mntner_text
        assert PASSWORD_HASH_DUMMY_VALUE in mntner_text
        assert 'PERSON-TEST' in mntner_text

        # After two seconds, a new export should have been generated by irrd #1,
        # loaded by irrd #2, and the objects should be available in irrd #2
        time.sleep(2)
        mntner_text = whois_query('127.0.0.1', self.port_whois2, 'TEST-MNT')
        assert 'TEST-MNT' in mntner_text
        assert PASSWORD_HASH_DUMMY_VALUE in mntner_text
        assert 'PERSON-TEST' in mntner_text

        # Load a key-cert. This should cause notifications to mnt-nfy (2x).
        # Change is authenticated by password for now.
        self._submit_update(self.config_path1, SAMPLE_KEY_CERT + '\npassword: md5-password')
        mails = self._retrieve_mails()
        assert len(mails) == 3
        assert b'\nSubject: SUCCESS: my subject\n' in mails[0]
        assert b'\nFrom: from@example.com\n' in mails[0]
        assert b'\nTo: Sasha <sasha@example.com>\n' in mails[0]
        assert b'\nCreate succeeded: [key-cert] PGPKEY-80F238C6\n' in mails[0]

        self._check_recipients_in_mails(mails[1:], [
            'mnt-nfy@example.net', 'mnt-nfy2@example.net'
        ])

        self._check_text_in_mails(mails[1:], [
            b'\nSubject: Notification of TEST database changes\n',
            b'\nFrom: from@example.com\n',
            b'\n> Message-ID: <1325754288.4989.6.camel@hostname>\n',
            b'\nCreate succeeded for object below: [key-cert] PGPKEY-80F238C6:\n',
            b'email footer',
            b'Generated by IRRd version ',
        ])

        # Use the new PGP key to make an update to PERSON-TEST. Should
        # again trigger mnt-nfy messages, and a mail to the notify address.
        self._submit_update(self.config_path1, SIGNED_PERSON_UPDATE_VALID)
        mails = self._retrieve_mails()
        assert len(mails) == 4
        assert b'\nSubject: SUCCESS: my subject\n' in mails[0]
        assert b'\nFrom: from@example.com\n' in mails[0]
        assert b'\nTo: Sasha <sasha@example.com>\n' in mails[0]
        assert b'\nModify succeeded: [person] PERSON-TEST\n' in mails[0]

        self._check_recipients_in_mails(mails[1:], [
            'mnt-nfy@example.net', 'mnt-nfy2@example.net', 'notify@example.com',
        ])

        self._check_text_in_mails(mails[1:], [
            b'\nSubject: Notification of TEST database changes\n',
            b'\nFrom: from@example.com\n',
            b'\n> Message-ID: <1325754288.4989.6.camel@hostname>\n',
            b'\nModify succeeded for object below: [person] PERSON-TEST:\n',
            b'\n@@ -1,4 +1,4 @@\n',
            b'\nNew version of this object:\n',
        ])

        # Check that the person is updated on irrd #1
        person_text = whois_query('127.0.0.1', self.port_whois1, 'PERSON-TEST')
        assert 'PERSON-TEST' in person_text
        assert 'Test person changed by PGP signed update' in person_text

        # After 1s, NRTM from irrd #2 should have picked up the change.
        time.sleep(1)
        person_text = whois_query('127.0.0.1', self.port_whois2, 'PERSON-TEST')
        assert 'PERSON-TEST' in person_text
        assert 'Test person changed by PGP signed update' in person_text

        # Submit an update back to the original person object, with an invalid
        # password and invalid override. Should trigger notification to upd-to.
        self._submit_update(self.config_path1, SAMPLE_PERSON + '\npassword: invalid\noverride: invalid\n')
        mails = self._retrieve_mails()
        assert len(mails) == 2
        assert b'\nSubject: FAILED: my subject\n' in mails[0]
        assert b'\nFrom: from@example.com\n' in mails[0]
        assert b'\nTo: Sasha <sasha@example.com>\n' in mails[0]
        assert b'\nModify FAILED: [person] PERSON-TEST\n' in mails[0]
        assert b'\nERROR: Authorisation for person PERSON-TEST failed: must by authenticated by one of: TEST-MNT\n' in mails[0]

        assert b'\nSubject: Notification of TEST database changes\n' in mails[1]
        assert b'\nFrom: from@example.com\n' in mails[1]
        assert b'\nTo: upd-to@example.net\n' in mails[1]
        assert b'\nModify FAILED AUTHORISATION for object below: [person] PERSON-TEST:\n' in mails[1]

        # Object should not have changed (again)
        person_text = whois_query('127.0.0.1', self.port_whois1, 'PERSON-TEST')
        assert 'PERSON-TEST' in person_text
        assert 'Test person changed by PGP signed update' in person_text

        # Submit a delete with a valid password for PERSON-TEST.
        # This should be rejected, because it creates a dangling reference.
        # No mail should be sent to upd-to.
        self._submit_update(self.config_path1, SAMPLE_PERSON + 'password: md5-password\ndelete: delete\n')
        mails = self._retrieve_mails()
        assert len(mails) == 1
        assert b'\nSubject: FAILED: my subject\n' in mails[0]
        assert b'\nFrom: from@example.com\n' in mails[0]
        assert b'\nTo: Sasha <sasha@example.com>\n' in mails[0]
        assert b'\nDelete FAILED: [person] PERSON-TEST\n' in mails[0]
        assert b'\nERROR: Object PERSON-TEST to be deleted, but still referenced by mntner TEST-MNT\n' in mails[0]
        assert b'\nERROR: Object PERSON-TEST to be deleted, but still referenced by key-cert PGPKEY-80F238C6\n' in mails[0]

        # Object should not have changed (again)
        person_text = whois_query('127.0.0.1', self.port_whois1, 'PERSON-TEST')
        assert 'PERSON-TEST' in person_text
        assert 'Test person changed by PGP signed update' in person_text

        # Submit a valid delete for all our new objects.
        self._submit_update(self.config_path1,
                            f'{SAMPLE_PERSON}delete: delete\n\n{SAMPLE_KEY_CERT}delete: delete\n\n' +
                            f'{SAMPLE_MNTNER}delete: delete\npassword: crypt-password\n')
        mails = self._retrieve_mails()
        print(mails)
        assert len(mails) == 4
        assert b'\nSubject: SUCCESS: my subject\n' in mails[0]
        assert b'\nFrom: from@example.com\n' in mails[0]
        assert b'\nTo: Sasha <sasha@example.com>\n' in mails[0]
        assert b'\nDelete succeeded: [person] PERSON-TEST\n' in mails[0]
        assert b'\nDelete succeeded: [mntner] TEST-MNT\n' in mails[0]
        assert b'\nDelete succeeded: [key-cert] PGPKEY-80F238C6\n' in mails[0]

        # TODO: why is notify@example.com not included?
        self._check_recipients_in_mails(mails[1:], [
            'mnt-nfy@example.net', 'mnt-nfy2@example.net', 'notify@example.net',
        ])

        # self._check_text_in_mails(mails[1:], [
        #     b'\nSubject: Notification of TEST database changes\n',
        #     b'\nFrom: from@example.com\n',
        #     b'\n> Message-ID: <1325754288.4989.6.camel@hostname>\n',
        #     b'\nDelete succeeded for object below: [person] PERSON-TEST:\n',
        #     b'\nDelete succeeded for object below: [mntner] TEST-MNT:\n',
        #     b'\nDelete succeeded for object below: [key-cert] PGPKEY-80F238C6:\n',
        # ])

        # Object should be deleted
        person_text = whois_query('127.0.0.1', self.port_whois1, 'PERSON-TEST')
        assert 'No entries found for the selected source(s)' in person_text
        assert 'PERSON-TEST' not in person_text

        # Object should be deleted from irrd #2 as well through NRTM.
        time.sleep(1)
        person_text = whois_query('127.0.0.1', self.port_whois2, 'PERSON-TEST')
        assert 'No entries found for the selected source(s)' in person_text
        assert 'PERSON-TEST' not in person_text

    def _start_mailserver(self):
        self.pidfile_mailserver = str(self.tmpdir) + '/mailserver.pid'
        self.logfile_mailserver = str(self.tmpdir) + '/mailserver.log'
        mailserver_path = IRRD_ROOT_PATH + '/irrd/integration_tests/mailserver.tac'
        assert not subprocess.call(['twistd', f'--pidfile={self.pidfile_mailserver}',
                                    f'--logfile={self.logfile_mailserver}', '-y', mailserver_path])

    # noinspection PyTypeChecker
    def _start_irrds(self):
        self.database_url1 = os.environ['IRRD_DATABASE_URL_INTEGRATION_1']
        self.database_url2 = os.environ['IRRD_DATABASE_URL_INTEGRATION_2']

        self.config_path1 = str(self.tmpdir) + '/irrd1_config.yaml'
        self.config_path2 = str(self.tmpdir) + '/irrd2_config.yaml'
        self.logfile1 = str(self.tmpdir) + '/irrd1.log'
        self.logfile2 = str(self.tmpdir) + '/irrd2.log'
        self.pidfile1 = str(self.tmpdir) + '/irrd1.pid'
        self.pidfile2 = str(self.tmpdir) + '/irrd2.pid'
        self.export_dir1 = str(self.tmpdir) + '/export1/'
        self.export_dir2 = str(self.tmpdir) + '/export2/'
        os.mkdir(self.export_dir1)
        os.mkdir(self.export_dir2)

        print(textwrap.dedent(f"""
            Preparing to start IRRd for integration test.
            
            IRRd #1 running on HTTP port {self.port_http1}, whois port {self.port_whois1}
            Config in: {self.config_path1}
            Database URL: {self.database_url1}
            PID file: {self.pidfile1}
            Logfile: {self.logfile1}

            IRRd #2 running on HTTP port {self.port_http2}, whois port {self.port_whois2}
            Config in: {self.config_path2}
            Database URL: {self.database_url2}
            PID file: {self.pidfile2}
            Logfile: {self.logfile2}
        """))

        base_config = {
            'irrd': {
                'access_lists': {
                    'localhost': ['::/32', '127.0.0.1']
                },

                'server': {
                    'http': {
                        'access_list': 'localhost',
                        'interface': '::0',
                        'port': 8080
                    },
                    'whois': {
                        'interface': '::0',
                        'max_connections': 50,
                        'port': 8043
                    },
                },

                'auth': {
                    'gnupg_keyring': None,
                    'override_password': None,
                },

                'email': {
                    'footer': 'email footer',
                    'from': 'from@example.com',
                    'smtp': f'localhost:{EMAIL_SMTP_PORT}',
                },

                'log': {
                    'logfile_path': None,
                    'loglevel': 'DEBUG'
                },

                'sources': {}
            }
        }

        config1 = base_config.copy()
        config1['irrd']['database_url'] = self.database_url1
        config1['irrd']['server']['http']['port'] = self.port_http1
        config1['irrd']['server']['whois']['port'] = self.port_whois1
        config1['irrd']['auth']['gnupg_keyring'] = str(self.tmpdir) + '/gnupg1'
        config1['irrd']['log']['logfile_path'] = self.logfile1
        config1['irrd']['sources']['TEST'] = {
            'authoritative': True,
            'keep_journal': True,
            'export_destination': self.export_dir1,
            'export_timer': '1',
            'nrtm_access_list': 'localhost',
        }
        with open(self.config_path1, 'w') as yaml_file:
            yaml.safe_dump(config1, yaml_file)

        config2 = base_config.copy()
        config2['irrd']['database_url'] = self.database_url2
        config2['irrd']['server']['http']['port'] = self.port_http2
        config2['irrd']['server']['whois']['port'] = self.port_whois2
        config2['irrd']['auth']['gnupg_keyring'] = str(self.tmpdir) + '/gnupg2'
        config2['irrd']['log']['logfile_path'] = self.logfile2
        config2['irrd']['sources']['TEST'] = {
            'keep_journal': True,
            'import_serial_source': f'file://{self.export_dir1}/TEST.CURRENTSERIAL',
            'import_source': f'file://{self.export_dir1}/test.db.gz',
            'export_destination': self.export_dir2,
            'import_timer': '1',
            'export_timer': '1',
            'nrtm_host': '127.0.0.1',
            'nrtm_port': str(self.port_whois1),
            'nrtm_access_list': 'localhost',
        }
        with open(self.config_path2, 'w') as yaml_file:
            yaml.safe_dump(config2, yaml_file)

        self._prepare_database()

        assert not subprocess.call(['twistd', f'--pidfile={self.pidfile1}', 'irrd', f'--config={self.config_path1}'])
        assert not subprocess.call(['twistd', f'--pidfile={self.pidfile2}', 'irrd', f'--config={self.config_path2}'])

    def _prepare_database(self):
        config_init(self.config_path1)
        alembic_cfg = config.Config()
        alembic_cfg.set_main_option('script_location', f'{IRRD_ROOT_PATH}/irrd/storage/alembic')
        command.upgrade(alembic_cfg, 'head')

        connection = sa.create_engine(self.database_url1).connect()
        connection.execute('DELETE FROM rpsl_objects')
        connection.execute('DELETE FROM rpsl_database_journal')
        connection.execute('DELETE FROM database_status')

        config_init(self.config_path2)
        alembic_cfg = config.Config()
        alembic_cfg.set_main_option('script_location', f'{IRRD_ROOT_PATH}/irrd/storage/alembic')
        command.upgrade(alembic_cfg, 'head')

        connection = sa.create_engine(self.database_url2).connect()
        connection.execute('DELETE FROM rpsl_objects')
        connection.execute('DELETE FROM rpsl_database_journal')
        connection.execute('DELETE FROM database_status')

    def _submit_update(self, config_path, request):
        email = textwrap.dedent("""
            From submitter@example.com@localhost  Thu Jan  5 10:04:48 2018
            Received: from [127.0.0.1] (localhost.localdomain [127.0.0.1])
              by hostname (Postfix) with ESMTPS id 740AD310597
              for <irrd@example.com>; Thu,  5 Jan 2018 10:04:48 +0100 (CET)
            Message-ID: <1325754288.4989.6.camel@hostname>
            Subject: my subject
            Subject: not my subject
            From: Sasha <sasha@example.com>
            To: sasha@localhost
            Date: Thu, 05 Jan 2018 10:04:48 +0100
            Content-Type: text/plain; charset=us-ascii
            X-Mailer: Python 3.7
            Content-Transfer-Encoding: 7bit
            Mime-Version: 1.0

        """).lstrip().encode('ascii')
        email += request.encode('ascii')

        script = IRRD_ROOT_PATH + '/irrd/scripts/submit_email.py'
        p = subprocess.Popen([script, f'--config={config_path}'], stdin=subprocess.PIPE)
        p.communicate(email)
        p.wait()

    def _retrieve_mails(self) -> List[bytes]:
        s = socket.socket()
        s.settimeout(5)
        s.connect(('localhost', EMAIL_SMTP_PORT))

        s.sendall(f'{EMAIL_RETURN_MSGS_COMMAND}\r\n'.encode('ascii'))

        buffer = b''
        while EMAIL_END not in buffer:
            data = s.recv(1024 * 1024)
            buffer += data
        buffer = buffer.split(b'\n', 1)[1]

        s.sendall(f'{EMAIL_DISCARD_MSGS_COMMAND}\r\n'.encode('ascii'))
        return [m.strip() for m in buffer.split(EMAIL_SEPARATOR.encode('ascii'))]

    def teardown_method(self, method):
        for pidfile in self.pidfile1, self.pidfile2, self.pidfile_mailserver:
            try:
                with open(pidfile) as fh:
                    os.kill(int(fh.read()), signal.SIGTERM)
            except (FileNotFoundError, ProcessLookupError, ValueError):
                pass

    def _check_text_in_mails(self, mails, expected_texts):
        for expected_text in expected_texts:
            for mail in mails:
                assert expected_text in mail, f'Missing text {expected_text} in mail:\n{mail}'

    def _check_recipients_in_mails(self, mails, expected_recipients):
        # Maintainer/notify notifications are unordered, so may occur in either order.
        assert len(mails) == len(expected_recipients)
        expected_recipients = set(expected_recipients)
        expected_headers = {(r, f'\nTo: {r}\n'.encode('ascii')) for r in expected_recipients}
        for mail in mails:
            for recipient, expected_header in expected_headers:
                if expected_header in mail:
                    expected_recipients.remove(recipient)
        assert not expected_recipients
